<script src=/resources/testharness.js></script>
<script src=/resources/testharnessreport.js></script>
<script src="/common/get-host-info.sub.js"></script>
<script src="/common/utils.js"></script>
<script src="./resources/common.js"></script>
<script src="./resources/dispatcher.js"></script>
<script>

const resource_path = directory + "/resources/empty";
const same_origin = get_host_info().HTTPS_ORIGIN;
const cross_origin = get_host_info().HTTPS_REMOTE_ORIGIN;

promise_test(async test => {
  const this_token_1 = token();
  const this_token_2 = token();

  // Create a COEP:credentialless document.
  const document_token = environments["document"](coep_credentialless);

  // Register a COEP:none ServiceWorker.
  const sw_token = token();
  const sw_url =
     sw_executor_js_path + coep_none + `&uuid=${sw_token}`;
  const sw_registration =
    await navigator.serviceWorker.register(sw_url);
  add_completion_callback(() => sw_registration.unregister());

  // Configure the ServiceWorker to proxy the fetch requests. Wait for the
  // worker to be installed and activated.
  send(sw_token, `
    fetchHandler = event => {
      if (!event.request.url.includes("${resource_path}"))
        return;

      send("${this_token_1}", "ServiceWorker: Proxying");

      // Response with a cross-origin no-cors resource.
      const url = "${cross_origin + resource_path}";

      event.respondWith(new Promise(async resolve => {
        try {
          let response = await fetch(url, {
            mode: "no-cors",
            credentials: "include"
          });
          send("${this_token_1}", "ServiceWorker: Fetch success");
          resolve(response);
        } catch (error) {
          send("${this_token_1}", "ServiceWorker: Fetch failure");
          resolve(new Response("", {status: 400}));
        }
      }));
    }

    await activated;
    send("${this_token_1}", serviceWorker.state);
  `)
  assert_equals(await receive(this_token_1), "activated");

  // The document fetches a same-origin no-cors resource. The requests needs to
  // be same-origin to be handled by the ServiceWorker.
  const url = same_origin + resource_path;
  send(document_token, `
    try {
      const response = await fetch("${url}", {
        mode: "no-cors",
        credentials: "include"
      });

      send("${this_token_2}", "Document: Fetch success");
    } catch (error) {
      send("${this_token_2}", "Document: Fetch error");
    }
  `);

  // The COEP:unsafe-none ServiceWorker is able to handle the cross-origin
  // no-cors request, requested with credentials.
  assert_equals(await receive(this_token_1), "ServiceWorker: Proxying");
  assert_equals(await receive(this_token_1), "ServiceWorker: Fetch success");

  // However, the COEP:credentialless Document is disallowed by CORP to get it.
  assert_equals(await receive(this_token_2), "Document: Fetch error");
}, "COEP:unsafe-none ServiceWorker");

// Using add_completion_callback above to unregister a ServiceWorker is a good
// thing to do in general. However unregistering a ServiceWorker is an
// asynchronous operation and add_completion_callback only supports simple
// functions. There are no guarantee the operation will be done on time for the
// next test. Do it for extra flakiness safety.
promise_test(async test => {
 const registrations = await navigator.serviceWorker.getRegistrations();
 await Promise.all(registrations.map(r => r.unregister()));
}, "Cleanup")

</script>
